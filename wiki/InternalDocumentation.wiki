#summary Describe the internals of the Syx VM
#labels Featured,Phase-Implementation

= Object =

This is the structure of an object:
{{{
typedef struct _SyxObject SyxObject;

struct _SyxObject {
  SyxObject *class;
  syx_varsize size;
  SyxObject **data;
};
}}}

The *size* field, is the number of elements contained in the *data* field.

= Memory =

The objects are inserted into a whole space of static memory:
{{{
static SyxObject **_syx_freed_memory[SYX_MEMORY_SIZE];
static SyxObject *_syx_memory[SYX_MEMORY_SIZE];
}}}

The idea is to keep a stack containing free memory pointers. Once we free an object, we push on top of the stack the freed location. When we allocate a new object, we just pop from the stack the pointer.

*Note*: _the *data* field, containing SyxObject pointers, is allocated outside this memory, in the heap*._

= Special objects =

== Numbers and constants ==

The pointer to objects can also represent other kind of objects:
  * *Pointers* (00) have the two least bits set to 0, the other 30 bits is the pointer.
  * *Small integers* (10) have the least bit set to 1, the other 31 bits is the signed integer.
  * *Characters* (01) have the the second least bit set to 1, and the least to 0, first 8 bits are the characters.
  * *nil* is 0
  * *true* is 1
  * *false* is 2

This method allows us to avoid allocating unuseful memory. For instance, small integers, characters and constants don't have other *data* to hold.

*syx_object_get_class()* will return the right class for these special objects.

== ByteArrays ==

For ByteArray instances, the *data* field is a pointer to an array of bytes instead of an array of SyxObject pointers.

This allows to manage strings and bytes much better than an array of integers and to save a bunch memory.